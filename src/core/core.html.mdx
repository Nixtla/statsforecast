---
description: >-
  Methods for Fit, Predict, Forecast (fast), Cross Validation and plotting
output-file: core.html
title: Core Methods
---

The core methods of `StatsForecast` provide a comprehensive interface for fitting, predicting, forecasting, and evaluating statistical forecasting models on large sets of time series.

## Overview

The main methods include:

- `StatsForecast.fit` - Fit statistical models
- `StatsForecast.predict` - Predict using fitted models
- `StatsForecast.forecast` - Memory-efficient predictions without storing models
- `StatsForecast.cross_validation` - Temporal cross-validation
- `StatsForecast.plot` - Visualization of forecasts and historical data

## StatsForecast Class

### `StatsForecast`

Bases: <code>[\_StatsForecast](#statsforecast.core._StatsForecast)</code>

The `StatsForecast` class allows you to efficiently fit multiple `StatsForecast` models
for large sets of time series. It operates on a DataFrame `df` with at least three columns
ids, times and targets.

The class has memory-efficient `StatsForecast.forecast` method that avoids storing partial
model outputs. While the `StatsForecast.fit` and `StatsForecast.predict` methods with
Scikit-learn interface store the fitted models.

The `StatsForecast` class offers parallelization utilities with Dask, Spark and Ray back-ends.
See distributed computing example [here](https://github.com/Nixtla/statsforecast/tree/main/experiments/ray).

#### `StatsForecast.fit`

```python
fit(
    df,
    prediction_intervals=None,
    id_col="unique_id",
    time_col="ds",
    target_col="y",
)
```

Fit statistical models.

Fit `models` to a large set of time series from DataFrame `df`
and store fitted models for later inspection.

**Returns:**

Name | Type | Description
---- | ---- | -----------
`StatsForecast` | | Returns with stored `StatsForecast` fitted `models`.

#### `StatsForecast.predict`

```python
predict(h, X_df=None, level=None)
```

Predict statistical models.

Use stored fitted `models` to predict large set of time series from DataFrame `df`.

**Returns:**

Type | Description
---- | -----------
| pandas or polars DataFrame: DataFrame with `models` columns for point predictions and probabilistic predictions for all fitted `models`.

#### `StatsForecast.fit_predict`

```python
fit_predict(
    h,
    df,
    X_df=None,
    level=None,
    prediction_intervals=None,
    id_col="unique_id",
    time_col="ds",
    target_col="y",
)
```

Fit and Predict with statistical models.

This method avoids memory burden due from object storage.
It is analogous to Scikit-Learn `fit_predict` without storing information.
It requires the forecast horizon `h` in advance.

In contrast to `StatsForecast.forecast` this method stores partial models outputs.

**Returns:**

Type | Description
---- | -----------
<code>[DataFrame](#utilsforecast.compat.DataFrame)</code> | pandas or polars DataFrame: DataFrame with `models` columns for point predictions and probabilistic predictions for all fitted `models`.

#### `StatsForecast.forecast`

```python
forecast(
    h,
    df,
    X_df=None,
    level=None,
    fitted=False,
    prediction_intervals=None,
    id_col="unique_id",
    time_col="ds",
    target_col="y",
)
```

#### `StatsForecast.forecast_fitted_values`

```python
forecast_fitted_values()
```

#### `StatsForecast.cross_validation`

```python
cross_validation(
    h,
    df,
    n_windows=1,
    step_size=1,
    test_size=None,
    input_size=None,
    level=None,
    fitted=False,
    refit=True,
    prediction_intervals=None,
    id_col="unique_id",
    time_col="ds",
    target_col="y",
)
```

#### `StatsForecast.cross_validation_fitted_values`

```python
cross_validation_fitted_values()
```

Access insample cross validated predictions.

After executing `StatsForecast.cross_validation`, you can access the insample
prediction values for each model and window. To get them, you need to pass `fitted=True`
to the `StatsForecast.cross_validation` method and then use the
`StatsForecast.cross_validation_fitted_values` method.

**Returns:**

Type | Description
---- | -----------
<code>[DataFrame](#utilsforecast.compat.DataFrame)</code> | pandas or polars DataFrame: DataFrame with insample `models` columns for point predictions and probabilistic predictions for all fitted `models`.

#### `StatsForecast.plot`

```python
plot(
    df,
    forecasts_df=None,
    unique_ids=None,
    plot_random=True,
    models=None,
    level=None,
    max_insample_length=None,
    plot_anomalies=False,
    engine="matplotlib",
    id_col="unique_id",
    time_col="ds",
    target_col="y",
    resampler_kwargs=None,
)
```

Plot forecasts and insample values.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`forecasts_df` | <code>pandas or polars DataFrame</code> | DataFrame ids, times and models. Defaults to None. | <code>None</code>
`unique_ids` | <code>list of str</code> | ids to plot. If None, they're selected randomly. Defaults to None. | <code>None</code>
`plot_random` | <code>[bool](#bool)</code> | Select time series to plot randomly. Defaults to True. | <code>True</code>
`models` | <code>[List](#typing.List)\[[str](#str)\]</code> | List of models to plot. Defaults to None. | <code>None</code>
`level` | <code>[List](#typing.List)\[[float](#float)\]</code> | List of prediction intervals to plot if paseed. Defaults to None. | <code>None</code>
`max_insample_length` | <code>[int](#int)</code> | Max number of train/insample observations to be plotted. Defaults to None. | <code>None</code>
`plot_anomalies` | <code>[bool](#bool)</code> | Plot anomalies for each prediction interval. Defaults to False. | <code>False</code>
`engine` | <code>[str](#str)</code> | Library used to plot. 'plotly', 'plotly-resampler' or 'matplotlib'. Defaults to 'matplotlib'. | <code>'matplotlib'</code>
`resampler_kwargs` | <code>[dict](#dict)</code> | Kwargs to be passed to plotly-resampler constructor. For further custumization ("show_dash") call the method, store the plotting object and add the extra arguments to its `show_dash` method. | <code>None</code>

#### `StatsForecast.save`

```python
save(path=None, max_size=None, trim=False)
```

Function that will save StatsForecast class with certain settings to make it
reproducible.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`path` | <code>[str](#str) or [Path](#pathlib.Path)</code> | Path of the file to be saved. If `None` will create one in the current directory using the current UTC timestamp. Defaults to None. | <code>None</code>
`max_size` | <code>[str](#str)</code> | StatsForecast object should not exceed this size. Available byte naming: ['B', 'KB', 'MB', 'GB']. Defaults to None. | <code>None</code>
`trim` | <code>[bool](#bool)</code> | Delete any attributes not needed for inference. Defaults to False. | <code>False</code>

#### `StatsForecast.load`

```python
load(path)
```

Automatically loads the model into ready StatsForecast.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`path` | <code>[str](#str) or [Path](#pathlib.Path)</code> | Path to saved StatsForecast file. | *required*

**Returns:**

Name | Type | Description
---- | ---- | -----------
`StatsForecast` | | Previously saved StatsForecast

## Usage Examples

### Basic Forecasting

```python
from statsforecast import StatsForecast
from statsforecast.models import AutoARIMA, Naive
from statsforecast.utils import generate_series

# Generate example data
panel_df = generate_series(n_series=9, equal_ends=False, engine='pandas')

# Instantiate StatsForecast class
fcst = StatsForecast(
    models=[AutoARIMA(), Naive()],
    freq='D',
    n_jobs=1,
    verbose=True
)

# Efficiently predict
fcsts_df = fcst.forecast(df=panel_df, h=4, fitted=True)
```

### Cross-Validation

```python
from statsforecast import StatsForecast
from statsforecast.models import Naive
from statsforecast.utils import AirPassengersDF as panel_df

# Instantiate StatsForecast class
fcst = StatsForecast(
    models=[Naive()],
    freq='D',
    n_jobs=1,
    verbose=True
)

# Perform cross-validation
cv_df = fcst.cross_validation(df=panel_df, h=14, n_windows=2)
```

### Prediction Intervals

```python
import pandas as pd
import numpy as np
from statsforecast import StatsForecast
from statsforecast.models import SeasonalNaive, AutoARIMA
from statsforecast.utils import AirPassengers as ap

# Prepare data
ap_df = pd.DataFrame({'ds': np.arange(ap.size), 'y': ap})
ap_df['unique_id'] = 0

# Forecast with prediction intervals
sf = StatsForecast(
    models=[
        SeasonalNaive(season_length=12),
        AutoARIMA(season_length=12)
    ],
    freq=1,
    n_jobs=1
)
ap_ci = sf.forecast(df=ap_df, h=12, level=(80, 95))

# Plot with confidence intervals
sf.plot(ap_df, ap_ci, level=[80], engine="matplotlib")
```

### Conformal Prediction Intervals

```python
from statsforecast import StatsForecast
from statsforecast.models import AutoARIMA
from statsforecast.utils import ConformalIntervals

sf = StatsForecast(
    models=[
        AutoARIMA(season_length=12),
        AutoARIMA(
            season_length=12,
            prediction_intervals=ConformalIntervals(n_windows=2, h=12),
            alias='ConformalAutoARIMA'
        ),
    ],
    freq=1,
    n_jobs=1
)
ap_ci = sf.forecast(df=ap_df, h=12, level=(80, 95))
```

## Advanced Features

### Integer Datestamps

The `StatsForecast` class can work with integer datestamps instead of datetime objects:

```python
from statsforecast import StatsForecast
from statsforecast.models import HistoricAverage
from statsforecast.utils import AirPassengers as ap
import pandas as pd
import numpy as np

# Create dataframe with integer datestamps
int_ds_df = pd.DataFrame({'ds': np.arange(1, len(ap) + 1), 'y': ap})
int_ds_df.insert(0, 'unique_id', 'AirPassengers')

# Use freq=1 for integer datestamps
fcst = StatsForecast(models=[HistoricAverage()], freq=1)
forecast = fcst.forecast(df=int_ds_df, h=7)
```

### External Regressors

Every column after `y` is considered an external regressor and will be passed to models that support them:

```python
from statsforecast import StatsForecast
from statsforecast.utils import generate_series
import pandas as pd

# Create data with external regressors
series_xreg = generate_series(10_000, equal_ends=True)
series_xreg['intercept'] = 1
series_xreg['dayofweek'] = series_xreg['ds'].dt.dayofweek
series_xreg = pd.get_dummies(series_xreg, columns=['dayofweek'], drop_first=True)

# Split train/validation
dates = sorted(series_xreg['ds'].unique())
valid_start = dates[-14]
train_mask = series_xreg['ds'] < valid_start
series_train = series_xreg[train_mask]
series_valid = series_xreg[~train_mask]
X_valid = series_valid.drop(columns=['y'])

# Forecast with external regressors
fcst = StatsForecast(models=[your_model], freq='D')
xreg_res = fcst.forecast(df=series_train, h=14, X_df=X_valid)
```

## Distributed Computing

The `StatsForecast` class offers parallelization utilities with Dask, Spark and Ray backends for distributed computing. See the [distributed computing examples](https://github.com/Nixtla/statsforecast/tree/main/experiments/ray) for more information.
